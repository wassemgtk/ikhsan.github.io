<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>Codeage</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/blog/feed.xml" />

    <link href="/stylesheets/all.css" rel="stylesheet" type="text/css" />
  </head>
  <body>

    <div id="main" role="main">
      


<nav>
  <h1 class="blog-title"><a href="/">Codeage</a></h1>
  <p class="blog-description">
    Pardon my ramblings about code and such
  </p>
  <div class="blog-lang">
    <a href="/">English</a> / <strong>Bahasa</strong>
  </div>
</nav>

      <p>Setelah melihat beberapa video WWDC dalam 2 minggu terakhir, saya akhirnya mencoba fitur-fitur baru dari xcode 7 dan Swift. Sekedar iseng-iseng, saya menggunakan prototipe aplikasi sederhana yang saya buat tahun lalu untuk coding test dari <a href="https://api.songkick.com">Songkick</a>. READMORE Saya namakan &ldquo;<strong>On Tour</strong>&rdquo;, ide dasar aplikasinya adalah untuk melihat jalur tur band-band kesayangan kita di peta.</p>

<p><img alt="On Tour" src="/blog/2015-06-28-porting-mini-project-objc-to-swift/ontour.gif" /></p>

<p>Berikut adalah beberapa catatan dan kesan saya saat mencoba menulis ulang basis kode dari Objective-C ke Swift 2.0.</p>

<h2>Penanganan Error</h2>

<p>Fitur-fitur bahasa Swift menurut saya sengaja dirancang agar kita memikirkan lebih seksama dengan penanganan error. Beberapa diantaranya adalah Optional, Guard, Throws dan Result.</p>

<h3>Optional</h3>

<p>Secara implisit seluruh objek yang kita buat dalam Objective-C adalah Optionals. Karena objek selain punya nilai, tapi bisa juga tidak (atau nil).</p>

<p>Lihat cuplikan kelas <code>Artist</code> yang saya tulis untuk Objective-C;</p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="c1">// Artist.h
</span><span class="k">@interface</span> <span class="nc">Artist</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSNumber</span> <span class="o">*</span><span class="n">artistID</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSDate</span> <span class="o">*</span><span class="n">onDateTour</span><span class="p">;</span>
<span class="k">@end</span>
</pre></td></tr></tbody></table>
</div>

<p>Tidak jelas terlihat dari ketiga properti, mana yang harus dipunyai seorang artis dan mana yang tidak. Bahkan kita bisa saja membuat sebuah objek artis tanpa properti sama sekali. Ini memaksa kita untuk ekstra hati-hati dalam mengolah sebuah kelas, karena compiler tidak punya pengetahuan terlalu jauh dan seluruh logika akan berada sepenuhnya di tangan developer.</p>

<p>Sekarang kita lihat kelas sama yang ditulis dengan Swift;</p>
<div class="highlight swift"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="c1">// Artist.swift</span>
<span class="kd">class</span> <span class="kt">Artist</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">var</span> <span class="nv">onTourDate</span><span class="p">:</span> <span class="kt">NSDate</span><span class="p">?</span>
<span class="p">}</span>
</pre></td></tr></tbody></table>
</div>

<p>Dalam cuplikan kode di atas, Swift akan menjamin bahwa properti <code>id</code> dan <code>name</code> akan selalu ada di sebuah objek <code>Artist</code>. Satu-satunya properti yang mungkin tidak dipunyai seorang <code>Artist</code> adalah <code>onTourDate</code>. Kita bahkan tidak bisa lagi membuat objek artis tanpa <code>id</code> dan <code>nama</code>, karena compiler akan selalu mengingatkan kita.</p>

<p>Kalau dipikir-pikir masuk akal toh? Artis kan pasti punya nama, dan juga pasti punya identifikasi dalam sistem. Namun, bisa saja seorang artis tidak punya jadwal tur karena sedang sibuk menggarap album. Dibandingkan Objective-C, Swift dan Optional-nya dapat membantu kita lebih jauh dalam memodelkan dan melogikakan objek di kehidupan nyata.</p>

<h3>Guard</h3>

<p>Guard adalah fitur baru yang diperkenalkan di Swift 2.0. Saya membiasakan untuk menerapkan &lsquo;early exit&rsquo; (atau kadang disebut bouncer pattern) dalam menangani error. Alasannya adalah karena pola ini mengajak saya untuk memikirkan penganganan error di awal blok kode saya. Selain itu saya menghemat indentasi karena &#39;happy path&rsquo; tetap di bagian kiri kode, bukan dalam if statement.</p>
<div class="highlight swift"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="c1">// ArtistViewController.swift</span>

<span class="k">var</span> <span class="nv">artist</span><span class="p">:</span> <span class="kt">Artist</span><span class="p">?</span>

<span class="kd">func</span> <span class="nf">openArtist</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">guard</span> <span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="n">artist</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="c1">// a dipastikan adalah artist yang valid</span>
  <span class="nf">openArtist</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table>
</div>

<h3>Throws</h3>

<p>Swift 2.0 juga memperkenalkan penanganan error default, yang berbeda dengan Objective-C. Mungkin programmer Java sudah cukup familiar dengan konsep try/catch, namun di Swift agak sedikit berbeda, do/try/throws/catch. Bahkan di SDK Apple terkini, beberapa method sudah mengadopsi konsep ini.</p>

<p>Sebagai contoh, lihat bagaimana biasa kita mengubah NSData menjadi NSDictionary di Objective-C</p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="c1">// header
</span><span class="k">+</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">JSONObjectWithData</span><span class="p">:(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span> <span class="nf">options</span><span class="p">:(</span><span class="n">NSJSONReadingOptions</span><span class="p">)</span><span class="nv">opt</span> <span class="nf">error</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>

<span class="c1">// implementation
</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="n">id</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSJSONSerialization</span> <span class="nf">JSONObjectWithData</span><span class="p">:</span><span class="n">data</span> <span class="nf">options</span><span class="p">:</span><span class="mi">0</span> <span class="nf">error</span><span class="p">:</span><span class="n">error</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// penanganan error
</span>  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// result dapat digunakan di sini
</span></pre></td></tr></tbody></table>
</div>

<p>Sedangkan pada Swift 2.0, memanggil method yang sama menjadi lebih mudah dimengerti dan pengangan error berada pada kode blok yang berbeda.</p>
<div class="highlight swift"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="c1">// header</span>
<span class="kd">class</span> <span class="kd">func</span> <span class="kt">JSONObjectWithData</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">NSData</span><span class="p">,</span> <span class="n">options</span> <span class="nv">opt</span><span class="p">:</span> <span class="kt">NSJSONReadingOptions</span><span class="p">)</span> <span class="n">throws</span> <span class="o">-&gt;</span> <span class="kt">AnyObject</span>

<span class="c1">// implementation</span>
<span class="k">do</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">try</span> <span class="kt">NSJSONSerialization</span><span class="o">.</span><span class="kt">JSONObjectWithData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="o">.</span><span class="kt">AllowFragments</span><span class="p">)</span> <span class="k">as!</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">]</span>
  <span class="c1">// result dapat digunakan di sini</span>
<span class="p">}</span> <span class="n">catch</span> <span class="p">{</span>
  <span class="c1">// penanganan error</span>
<span class="p">}</span>
</pre></td></tr></tbody></table>
</div>

<h3>Enum + Generics = Result</h3>

<p>Sayangnya throws bukanlah cara penanganan error yang cocok untuk segala situasi. Throws mudah digunakan untuk pekerjaan yang synchronous, tapi sulit diterapkan di pekerjaan asynchronous seperti pengambilan data dari network.</p>

<p>Throws akan bermasalah bila kita panggil dari dalam closure, karena yang akan menerima &#39;lemparan&rsquo;-nya adalah si closure itu sendiri, bukan fungsi yang memanggilnya. Compiler akan mengingatkan kita kalau tipe closure tidak cocok, karena deklarasinya tanpa throws tapi diimplementasinya menggunakan throws. Lebih lengkapnya, Nick Lockwood menulis pemikirannya tentang hal ini di poin #2 pada tulisannya, <a href="https://gist.github.com/nicklockwood/21495c2015fd2dda56cf">Thoughts on Swift 2 Errors</a>.</p>

<p>Bahkan kalau kita tilik kembali SDK terakhir, Apple belum mengadopsi throws untuk method-method asynchronous-nya. Method masih mengoper error sebagai parameternya (lihat <a href="https://developer.apple.com/library/prerelease/ios/documentation/Foundation/Reference/NSURLSession_class/index.html#//apple_ref/occ/instm/NSURLSession/dataTaskWithRequest:completionHandler:"><code>dataTaskWithRequest: completionHandler:</code></a> ).</p>

<p>Lalu apa alternatif lain yang lebih cocok? Pada functional programming, error handling pada async task biasa menggunakan sebuah tipe khusus, Result. Result ini bisa kita gunakan di swift dengan mengkombinasikan enum and generics. Berikut sintaks dari tipe Result :</p>
<div class="highlight swift"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="kd">enum</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">,</span> <span class="kt">Error</span><span class="p">:</span> <span class="kt">ErrorType</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Success</span><span class="p">(</span><span class="kt">T</span><span class="p">)</span>
    <span class="k">case</span> <span class="kt">Failure</span><span class="p">(</span><span class="kt">Error</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table>
</div>

<p>Mudahnya, Result adalah tipe yang punya dua kemungkinan, yaitu sukses atau gagal. Kalau sukses Result berisi sebuah tipe apapun (disimbolkan dengan huruf T), sedangkan kalau gagal Result berisi error.</p>

<p>Sebelum melihat penerapan result pada pekerjaan yang asynchronous, kita lihat dulu kode Objective-C yang umum kita gunakan saat memanggil data dari jaringan. Perhatikan parameter dari completion block-nya.</p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><pre><span class="c1">// SongkickAPI.h
</span><span class="k">+</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">searchArtist</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span>
    <span class="nf">page</span><span class="p">:(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">page</span>
    <span class="nf">completion</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">results</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completion</span><span class="p">;</span>

<span class="c1">// SearchViewController.m
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">searchButtonClicked</span> <span class="p">{</span>
  <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span>
  <span class="p">[</span><span class="n">SongkickAPI</span>
   <span class="nf">searchArtist</span><span class="p">:</span><span class="s">@"Bad"</span>
   <span class="nf">page</span><span class="p">:</span><span class="mi">1</span>
   <span class="nf">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">results</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// penanganan error
</span>        <span class="k">return</span>
      <span class="p">}</span>
      <span class="c1">// penggunaan artis terlacak
</span>  <span class="p">}];</span>
<span class="p">}</span>
</pre></td></tr></tbody></table>
</div>

<p>Kita telaah kenapa menggunakan dua parameter untuk completion block kurang baik. Pada kasus di atas, ada 4 kemungkinan yang terjadi; (results, nil), (nil, error), (results, error), (nil, nil). Dari empat, dua diantaranya tidak masuk di akal. Kita bisa saja berikan results dan error yang tidak nil, atau results dan error yang sama-sama nil. Dua kemungkinan ini <strong>valid</strong> di mata compiler, padahal tidak masuk logika.</p>

<p>Sekarang kita bandingkan dengan Swift + Result</p>
<div class="highlight swift"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><pre><span class="c1">// SongkickAPI.swift</span>
<span class="kd">class</span> <span class="kd">func</span> <span class="nf">searchArtist</span><span class="p">(</span>
  <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
  <span class="nv">page</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// swift bisa memberikan default value</span>
  <span class="nv">completionHandler</span><span class="p">:</span> <span class="p">(</span><span class="kt">Result</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">Artist</span><span class="p">],</span> <span class="kt">ErrorType</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">NSURLSessionDataTask</span>
<span class="p">)</span>

<span class="c1">// SearchViewController.swift</span>
<span class="kd">func</span> <span class="nf">buttonClicked</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">SongkickAPI</span><span class="o">.</span><span class="nf">searchArtist</span><span class="p">(</span><span class="s">"Bad"</span><span class="p">)</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">result</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="kt">Success</span><span class="p">(</span><span class="k">let</span> <span class="nv">artists</span><span class="p">):</span>
      <span class="c1">// penggunaan artis terlacak</span>
    <span class="k">case</span> <span class="o">.</span><span class="kt">Failure</span><span class="p">(</span><span class="k">let</span> <span class="nv">error</span><span class="p">):</span>
      <span class="c1">// penanganan error</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

</pre></td></tr></tbody></table>
</div>

<p>Dengan Result, ini lebih bagus dan lebih masuk diakal. Parameter pada completion handler cukup satu saja. Kemungkinannya hanya dua, sukses berarti yang memberikan daftar artis, atau gagal yang memberikan informasi kegagalan pada error. Untuk kasus ini, saya puas menggunakan Result karena kode menjadi lebih bersih, lebih jelas dan lebih benar.</p>

<h2>Akses Privat untuk Unit Test</h2>

<p>Seringkali kita mengekspos kelas atau method kita yang sebenarnya private menjadi publik hanya untuk bisa di test di unit test kita. Sekarang di Swift 2.0, tidak perlu lagi kita memodifikasi kode hanya untuk supaya bisa dites. Biarkan saja kode kita apa adanya, lalu gunakan <code>@testable</code> pada unit test kita 🎉.</p>
<div class="highlight swift"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="c1">// Tests.swift</span>
<span class="kd">import</span> <span class="kt">XCTest</span>
<span class="err">@testable</span> <span class="o">&lt;</span><span class="n">nama</span> <span class="n">modul</span><span class="o">&gt;</span>

<span class="c1">// tes dapat akses pada kelas dan method privat</span>
</pre></td></tr></tbody></table>
</div>

<p>Panduan lebih mudahnya bisa dilihat di blognya <a href="http://natashatherobot.com/swift-2-xcode-7-unit-testing-access">Natasha</a>.</p>

<h2>Jumlah Baris pada Kode</h2>

<p>Jumlah baris kode bukanlah metrik penentu kualitas sebuah kode, namun untuk mencari metrik yang sederhana maka akan tetap saya gunakan. Menulis kode Swift harus lebih terinci karena sifatnya <em>type safety</em>, walau begitu jumlah baris kodenya lebih sedikit dibanding Objective-C.</p>

<p>Untuk menghitung jumlah baris kode, kita bisa menggunakan perintah <code>find</code> dari terminal:</p>
<div class="highlight shell"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="gp">$ </span>find . <span class="se">\(</span> -iname <span class="se">\*</span>.m -o -iname <span class="se">\*</span>.h -o -iname <span class="se">\*</span>.swift <span class="se">\)</span> -exec wc -l <span class="s1">'{}'</span> <span class="se">\+</span>
</pre></td></tr></tbody></table>
</div>

<p><strong>Kode Objective-C</strong></p>

<ul>
<li>+-1370 baris</li>
<li>dua file (<code>ViewController</code> dan kelas Networking) melebihi 200 baris</li>
</ul>

<p><strong>Kode Swift</strong> <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<ul>
<li>+-980 baris</li>
<li>kelas dengan baris terbanyak adalah sebuah kelas <code>ViewController</code> dengan 145 baris</li>
</ul>

<p>Menggunakan Swift memang membuat kode menjadi lebih ramping. Sintaks Swift terlihat lebih sederhana dan lebih nyaman dilihat. Tidak ada detil rumit yang tidak perlu, seperti bintang untuk <em>pointer</em>, dua bintang untuk passing <code>NSError</code> dan titik koma pada akhir baris.</p>

<p>Compiler Swift juga pintar dalam menyimpulkan tipe data. Sehingga kita tidak perlu menulis secara gamblang semua tipe variabel atau fungsi seperti yang kita lakukan di Objective-C.</p>

<h2>Kelemahan</h2>

<p>Saya sempet mencoba menggunakan UI Testing untuk aplikasi ini, namun ternyata performanya tidak sebagus yang terlihat di keynote. UI Testing pada Xcode 7b2 masih mudah crash, terutama bila kita gunakan aplikasi kita secara cepat. Tapi fitur ini sangat menjanjikan dan semoga bisa lebih robust dan stabil ke depannya.</p>

<p>Begitu juga dengan fitur Playground. Seringkali saya memulai mencoba apa yang ada di kepala Playground terlebih dahulu, bila terbukti berhasil baru saya kopas ke dalam proyek utama. Namun apa daya Playground masih suka crash dan akhirnya saya koding langsung kembali di proyek utama.</p>

<h2>Penutup</h2>

<p>Ini adalah waktu yang bergairah untuk menjadi Swift developer. Bahasanya jauh lebih modern dan lebih lengkap daripada Objective-C, bisa dilihat dari contoh-contoh di atas yang saya alami. Apalagi fitur-fitur bahasa ini masih akan terus berubah dan berkembang. Jangan lupa, akhir tahun Swift akan jadi open source dan bisa dijalankan di Linux. Saya tidak sabar untuk bisa membuat website dan aplikasi dengan Swift!</p>

<p>Bila tertarik untuk mengecek proyek utuhnya silahkan lihat repositorynya, <a href="https://github.com/ikhsan/On-Tour">On Tour</a>.</p>

<p>Makasih ya sudah membaca!</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Saya sedikit curang karena saya menggunakan library pemilahan JSON, <a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJSON</a>, yang tidak saya masukkan dalam perhitungan baris. Pemilahan data JSON yang sederhana sekalipun masih ribet dan memang masih menjadi topik hangat di komunitas Swift.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

      <footer>
  <div class="footer-blog">
    <p>
      Saya Ikhsan dan ini adalah blog saya tentang pemikiran seputar koding. Hal-hal selain kodingan saya tulis di blog utama, <a href="http://ikhsan.me">Lifeage</a>. Kontak saya via Twitter <a href="http://twitter.com/ixnixnixn">@ixnixnixn</a> atau langsung saja email di <a href="mailto:ikhsan.assaat@gmail.com">ikhsan.assaat@gmail.com</a>.
    </p>
  </div>

  <div class="footer-links">
  <ul>
    <li><a href="http://twitter.com/ixnixnixn">Twitter</a></li>
    <li><a href="http://github.com/ikhsan">Github</a></li>
    <li><a href="http://ikhsan.me">Lifeage</a></li>
  </ul>

  <div class="copyright">
    <p>&copy; Codage 2009–2015</p>
  </div>
</div>


</footer>

    </div>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-12712252-2', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>
